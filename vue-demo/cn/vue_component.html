<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>vue_component</title>
</head>
<body>
<div>
    <!--父子组件-->
    <div id="app-8">
        <parent></parent>
    </div>
    <div id="app-9">
        <p>{{foo}}</p>
        <!-- 这里的 `foo` 不会更新！ -->
        <button v-on:click="foo = 'baz'">Change it</button>
    </div>
    <div id="app-11">
        <p>Original message:"{{message}}"</p>
        <p>Computer reversed message:"{{reversedMessage}}"</p>
    </div>
    <div id="app-12">
        <p>{{fullName}}</p>
    </div>
    <!--计算属性会依赖于他使用的data中的属性，只要是依赖的属性值有改变，则自动重新调用一下计算属性；
    如果他所依赖的这些属性值没有发生改变，那么计算属性的值是从缓存中来的，而不是重新编译，那么性能要高一些，所以vue中尽可能使用computed替代watch。-->
    <div id="app-13">
        <input type="text" v-model="firstName" />
        <input type="text" v-model="lastName" />
        {{fullName}}
    </div>

</div>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
    var childNode = {
        template:'<div>被包含的子组件</div>'
    };
    var parentNode = {
        template:'<div>' +
            '<child></child>' +
            '<child></child>' +
            '</div>',
        components: {
            child:childNode
        }};
    var app8 = new Vue({
        el: "#app-8",
        components:{
            parent:parentNode
        }
    });
    //创建两个组件 parent 和 child。需要保证每个组件可以在相对隔离的环境中书写，这样也能提高组件的可维护性

    //使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化
    var obj = {
        foo: 'bar'
    };
    Object.freeze(obj);
    new Vue({
        el: '#app-9',
        data: obj
    });

    var app10 = new Vue({
        el:'#app-10',
        data:{
            a:1
        },
        create:function () {
            // `this` 指向 vm 实例
            console.log('a is :'+this.a)
        }
    });
    var app11 = new Vue({
        el:'#app-11',
        data:{
            message:'hello'
        },
        computed:{
            // 计算属性的 getter
            reversedMessage:function () {
                // `this` 指向 vm 实例
                return this.message.split('').reverse().join('')
            }
        }
    });
//计算属性computed
   var app12 = new Vue({
        el:'#app-12',
        data:{
            firstName:'Whiskey',
            lastName:'Def',
            fullName:'Whiskey Def'
        },
       computed: {
           fullName:function(){
               return this.firstName()+' '+this.lastName
           }
       }
    });
   //利用命令式watch回调
   var app13 = new Vue({
        el: '#app-13',
        data:{
            firstName: 'hello',
            lastName: 'vue',
            fullName: 'hello.ve'
        },
        watch: {
            firstName:function(newval, oldval) {
                // console.log(newval,oldval);
                this.fullName = this.firstName + this.lastName;
            },
            lastName:function(newval, oldval) {
                // console.log(newval,oldval);
                this.fullName = this.firstName + this.lastName;
            }
        }
    });

</script>
</body>
</html>